---
title: Chapter 2: Part 1, Tabular Data
author: Jay Skovlin, Dylan Beaudette, Stephen Roecker
date: "February 2016"
output:
  html_document:
    keep_md: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: false
---


![Statistics for pedologists course banner image](figure/logo.jpg)

```{r setup, echo=FALSE, results='hide', warning=FALSE, message=FALSE}
library(knitr, quietly=TRUE)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.align='center', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE)
options(width=100, stringsAsFactors=FALSE)
```

# Getting Acquainted With the SoilDB Package

What if you could extract, organize, and visualize data from NASIS (or many other commonly used sources) with a couple of lines of code? You can! 

```{r eval=FALSE}
library(soilDB)
pedons <- fetchNASIS()
# a couple more steps ...
plot(pedons)
```

<img src="figure/aqp_profile_plot_example_sjer.png" border="0">


## Objectives
- Learn more about R and how to inspect objects and data types
- Use the soilDB package to load NASIS pedon data into R
- Learn about the checks run by the fetch functions when pulling data into R
- Understand the structure of data stored in a Soil Profile Collection (SPC)
- Learn ways to filter and subset SPC data in R
- Learn how functions can be used to bundle operations
- Review additional data that is accessible via extended data functions


## Importance of Pedon Data

The importance of pedon data for present and future work cannot be overstated.  These data represent decades of on-the-ground observations of the soil resource for a given area.  As difficult as it may be to take the time to enter legacy pedon data, it is vitally important that we capture this resource and get these data into NASIS as an archive of point observations.  

```{r pedons_a, echo=FALSE, results='hide', warning=FALSE}
library(ggplot2)
# assemble data on number of pedon by decade
Pedons <- c(577, 6152, 9517, 19058, 42587, 112182, 231609, 184913)
Year <- c("<1950s", "1950s", "1960s", "1970s", "1980s", "1990s", "2000s", "2010s")
 
cat("# pedons = ", formatC(sum(Pedons), big.mark = ",", format = "fg"), "\n", "# lab pedons = ~64,000", sep = "")

# plot number of pedons in NASIS 
ggplot(data.frame(Pedons, Year), aes(x=Year, y=Pedons)) + geom_bar(stat="identity")
``` 

### Some Issues With Pedon Data

- Making and documenting observations of soil requires hard work. Digging is difficult, and writing soil descriptions is time consuming!
- Our confidence in observations commonly weakens with the depth of the material described.
    
  - If we acknowledge this, which we must, then how do we deal with it in pedon data?
      - A cutoff depth, for example 100 cm, can be used to truncate observations to a zone of greater confidence.
    

# R Fundamentals

The following examples are meant to be copied from this document and pasted into **R,** where they can run interactively. Comments (green text with a "#" sign at left) briefly describe the function of the code in each line. Further documentation on objects and functions from the `aqp` package can be accessed by typing `help(soilDB)` or `help(aqp)` at the R console. The general form for a help request is `?function_name`. 
  
## Classes of Objects Used in R
 
One of the most versatile things about R is that it can manipulate and work with data in many ways.  Below are examples of ways to create and reference information in several data types that are commonly used with soil data. Within the R session, *objects* contain information that is loaded from files, extracted from NASIS, created on the fly, or calculated by some function. If none of the base classes are sufficient for a task, it is possible to define custom classes. The `SoilProfileCollection` is one such example.

Objects in R are analogous to nouns in a spoken language. They are labels for things we encounter in life. While the meaning of a noun in a spoken language generally doesn't change (e.g., the meaning of the word "apple" doesn't randomly change), the contents of objects in R can be modified or re-assigned at any time by using the assignment operator (`<-`).  
 
### Vectors
Vectors are a fundamental object in the R language. They represent a set of 1 or more numbers, characters (commonly called strings), or Boolean (true/false) values.
```{r datatype1, eval=TRUE, collapse=FALSE}
 # implicit vector creation from a sequence from 1:10
 1:10

 # numeric vector example: clay percent values
 clay <- c(10, 12, 15, 26, 30)
 
 # 'c()' is the concatenate function
 # values are concatenated into an object we've called 'clay' by assigning the concatenate result to 'clay' using '<-' or '='
 # print the values of 'clay' by typing it into the R console followed by enter
 clay
 
 # character vector: taxonomic subgroup
 subgroup <- c("typic haplocryepts","andic haplocryepts","typic dystrocryepts")  
 subgroup
 
 # logical vector: diagnostic feature presence/absence
 # note that TRUE and FALSE must be capitalized
 andic <- c(FALSE,TRUE,FALSE) 
 andic
```

#### Referencing elements of a vector
Specific elements from a vector are accessed with square brackets, e.g., `clay[i]`. Note that the examples below use vectors to reference elements of another vector.
```{r datatype1.1, eval=TRUE}
 # 2nd and 4th elements of vector 'clay' from above
 clay[c(2, 4)] 

 # 1st and 3rd elements of vector 'subgroup' from above
 subgroup[c(1, 3)]
 
 # everything but the first element of vector 'andic'
 andic[-1]
 
 # re-order clay values using a sequence from 5 to 1
 clay[5:1]
```

So what's the deal with the square bracket notation? 

 * Access elements `i` from vector `x`: `x[i]`. 
 
 * Exclude elements `i` from vector `x`: `x[-i]`.
 
 
#### Vectorized evaluation: Implicit looping
Most functions in R are "vectorized." This means that operations such as addition (the `+` function) on vectors will automatically iterate through every element. Following are some examples to demonstrate these concepts.
```{r datatype1.2, eval=TRUE}
 # clay values from above
 # divide by 100, notice that iteration over the elements of 'clay' is implicit
 clay / 100
 
 # search for the text 'dyst' in elements of 'subgroup'...more on this process later!
 grepl('dyst', subgroup)
 
 # multiply two vectors of the same length
 c(5, 5) * c(1, 2)
 
 # be careful, operations on vectors of different length results in "recycling"!
 # this is helpful at times, but can be a common source of confusion
 10 * c(1, 2)
 c(1, 10, 100) + c(1, 2)
```



### Dataframes

Dataframes are central to most work in R. They describe rectangular data, which can be thought of as a spreadsheet with rows and columns. Each column in the dataframe is constrained to a single data type: numeric, date-time, character, Boolean, and so on. Note that each column of a dataframe is a vector, and all column vectors must be the same length (hence the adjective "rectangular").

```{r datatype2, eval=TRUE}
  # Take our two character and logical vectors we created above and convert them into a more useful dataframe.
  # we'll use the data.frame() function to glue these two vectors together into object 'd'
  d <- data.frame(subgroup, andic)
  d
``` 
You can see that the dataframe was created and it worked, but the vector names are not very informative. A couple of useful functions for working with column names are `names()`, which renames columns in a dataframe and `colnames()`, which creates a vector of column names.

```{r datatype2.1, eval=TRUE}  
  # get the column names of a dataframe
  names(d)
  # we can use 'names()' and 'c()' to rename the columns in a dataframe
  names(d) <- c('tax_subgroup', 'andic.soil.properties')
  d
```

#### Referencing within dataframes
Note in dataframe `d` that each row has an index number in front of it.  Using the square brackets notation, you can reference any part of a dataframe: rows or columns or specific row- and column-selections.  Here are some examples:
  
```{r datatype2a, eval=TRUE}
  # format: dataframe_name[rows, columns]
  d[1, ] # first row of dataframe
  d[, 1] # first column of dataframe
  d[2, 2] # second row, second column
  
  # In dataframes we can also use the '$' symbol to reference vector columns within a specific dataframe object
  d$tax_subgroup
  
  # Other useful functions for checking objects and working with dataframes
  # the 'str()' function will show you the structure of an object and the data types of the vectors within it
  str(d)
  # 'class()' will tell you the object type or data type
  class(d)
  # use 'colnames()' to get a vector of column names from a dataframe
  colnames(d)
  # ncol and nrow give dimensions
  ncol(d)
  nrow(d)
  
  # building on what we've learned above, we can use the square bracket notation on a dataframe to re-order columns
  d <- d[ ,c('andic.soil.properties', 'tax_subgroup')]
  d
  # another way we could do this is to use the column indexes within the concatenate function
  d <- d[ , c(2,1)]
``` 

How would you remove a vector or column from a dataframe?

`d$tax_subgroup <- NULL` will remove this column from the dataframe.


### Factors
Factors are an extension of the character class, designed for encoding group labels. This object (and some possible issues that it can create) are described in a later section.
```{r factors, eval=TRUE}
# generate a factor representation of the characters contained in the word 'pedology'
# also setting the range of possibilities to the letters of the alphabet
x <- factor(substring("pedology", 1:8, 1:8), levels = letters)
# note that the object 'x' knows that there are 26 possible levels
x
# another way to do the same thing - the substring() is parsing the string 'pedology' for us in the above example
#x <- factor(c('p', 'e', 'd', 'o', 'l', 'o', 'g', 'y'), levels=letters)
# what happens when the levels are not specified?
factor(substring("mississippi", 1:11, 1:11)) 
```

### Lists
Lists are similar to the dataframe class but without limitations on the length of each element. Lists are commonly used to store tree-like data structures or "ragged" data: elements with varying length. List elements can contain just about anything, making them one of the most flexible objects in R. Again, examples are most useful.

```{r datatype3, eval=TRUE}
# make a list with named elements
l <- list('favorite shovels'=c('sharpshooter', 'gibbs digger', 'auger', 'rock bar', 'backhoe!'),
     'food'=c('apples', 'bread', 'cheese', 'vienna sausages', 'lutefisk'),
     'numbers I like'=c(12, 1, 5, 16, 25, 68),
     'chips I like' =c('plantain', 'tortilla', 'potato', '10YR 3/2'),
     'email messages deleted'=c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE))
# check
l

# access the first element of the list, note the double square brackets
l[[1]]

# access the element named 'food'
l[['food']]

# convert a dataframe into a list
as.list(d)

# a list of lists
list.of.lists <- list('pedon_1'=list('top'=c(0,10,25,55), 'bottom'=c(10,25,55,76), 'pH'=c(6.8,6.6,6.5,6.4)))
list.of.lists

# convert list of elements with equal length into a data.frame
as.data.frame(list.of.lists)
```

### Matrix
The matrix object is used to describe rectangular data of a single datatype: numbers, characters, Boolean values, and so on.
```{r datatype4, eval=TRUE}
# make a 5x5 matrix of 0's
m <- matrix(0, nrow=5, ncol=5)

# operations by scalar (single value) are vectorized
m <- m + 1
m * 5

# square bracket notation is used to get / set values: m[row, col]
# set row 1, col 1 to 0
m[1,1] <- 0
m

# access diagonal and upper/lower triangles, useful for chapter 5
m[upper.tri(m)] <- 'U'
m[lower.tri(m)] <- 'L'
diag(m) <- 'D'
m

# many functions return matrix objects
#  create a matrix of the sequences 1:10 and 1:10, then multiply every combination by applying a function
outer(1:10, 1:10, FUN='*')
```

# Using the SoilDB Package to Load NASIS Pedon Data
 
## Set Up an Open Database Connectivity (ODBC) Connection to NASIS  

After setting up an ODBC connection, you can use R to access data from a selected set defined in your local NASIS database. See this job aid: [**How to Create an ODBC Connection and Setup SoilDB for Use with R**](http://ncss-tech.github.io/AQP/soilDB/setup_local_nasis.html).

Query and load some pedon data into your NASIS selected set.
 
Does NASIS need to be open and running to query data using soilDB?

No, `fetchNASIS()` works whether the NASIS application is running or not. You just need to make sure that the data you want is loaded into your selected set.


## What is the SoilDB Package, and What Does It Do?
The soilDB package for R works with soil-resource-related data sources.  It has a series of convenience functions for accessing data in NASIS, KSSL, SDA, and other sources. The `fetchNASIS` convenience function extracts data from a NASIS selected set via Structured Query Language (SQL). Basic data checks are run within the fetch functions, then the data are assembled into a combined site-level and horizon-level data structure within a custom R object called a `Soil Profile Collection (SPC)`.  The [`SoilProfileCollection`](http://ncss-tech.github.io/AQP/aqp/aqp-intro.html) class simplifies the process of working with collections of data associated with soil profiles, e.g., site-level data, horizon-level data, spatial data, diagnostic horizon data, metadata, etc.  

Note that the import process in `fetchNASIS()` is not comprehensive. It does not pull all of the data for every table related to pedon data out of NASIS. Instead, it pulls much of the most commonly used pedon and horizon data.  In addition, much of the nested complexity of the NASIS data structure is simplified in the resulting SPC object.  Higher level functions like `fetchNASIS()` bundle a series of lower level functions that get specific parts of the data structure. 

```{r structure_diagram_a, echo=FALSE, results='hide', warning=FALSE}
library(diagram, quietly=TRUE)
# reset figure margins
par(mar = c(1, 1, 1, 1))

# simple diagram of the pedon data structure
names <- c("Site", "Siteobs", "Pedon", "Horizon")
M <- matrix(nrow = 4, ncol = 4, byrow = TRUE, data = 0)
M[4, 3] <- M[3, 2] <- M[2, 1] <- ""
pos <- cbind (c(1, 1, 1, 1))
plotmat(M, pos = pos, name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.size = 0.1, box.type = "square", box.prop = 0.4, mx=-0.2)

# parallel simplified SPC structure
names <- c("Site-level", "Horizon-level")
M <- matrix(nrow = 2, ncol = 2, byrow = TRUE, data = 0)
 M[2, 1] <- ""
#pos <- cbind (c(2, 2))
plotmat(M, pos = c(1, 1), name = names, lwd = 1, box.lwd = 2, cex.txt = 0.8, box.size = 0.14, box.type = "square", box.prop = 0.75, mx=0.3, my=-0.1, add=TRUE)

# add arrows to the diagram
arrows(0.42, 0.1, x1=0.65, y1=0.1, length = 0.25, code=2, lwd=2, angle = 15)
arrows(0.42, 0.35, x1=0.65, y1=0.54, length = 0.25, code=2, lwd=2, angle = 15)
arrows(0.42, 0.61, x1=0.65, y1=0.61, length = 0.25, code=2, lwd=2, angle = 15)
arrows(0.42, 0.87, x1=0.65, y1=0.68, length = 0.25, code=2, lwd=2, angle = 15)
```

One-to-many relationships are flattened where possible by `fetchNASIS()`. This flatteneing aggregates the data into one site record with related horizon records.  Selected additional data elements that may have a one-to-many relationship to a site or pedon can be gathered from a NASIS selected set via the  `get_extended_data_from_NASIS_db()` function.

In short, the soilDB package greatly simplifies the process of getting pedon data from NASIS into R for further analysis.



### Additional Convenience Functions in the SoilDB Package

- **fetchNASISLabData()**
    - Gets KSSL laboratory pedon/horizon layer data from a local NASIS database.
- **fetchNASIS_component_data()**
    - Gets selected NASIS map unit and component data from a local NASIS database (experimental).
        - For more information, see the following tutorial:
        [**NASIS Component Data**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/NASIS-component-data.html).
- **fetchKSSL()**
    - Gets KSSL data from the SoilWeb system via BBOX, MLRA, or series name query.
        - For more information, see the following tutorial:
        [**KSSL Data Demo**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/NASIS-component-data.html).
- **fetchOSD()**
    - Fetches a limited subset of horizon- and site-level attributes for named soil series from the SoilWeb system.
- **fetchRaCA()**
    - Gets Rapid Carbon Assessment (RaCA) data by State, geographic bounding-box, RaCA site ID, or series query from the SoilWeb system.
        - For more information, see the following tutorial:
        [**RaCA Data Demo**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/RaCA-demo.html).
- **fetchSCAN()**
    - Queries soil and climate data from USDA-NRCS SCAN Stations (experimental).
- **fetchHenry()**
    - Downloads data from the Henry Mount Soil Climate Database (experimental).
        - For more information, see the following tutorial:
        [**Henry Mount Soil Climate Database Tutorial**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/Henry-demo.html).
- **fetchPedonPC()**
    - Fetches commonly used site and horizon data from a PedonPC v.5 database.
- **SDA_query**
    - Submits queries to the Soil Data Access system.
        - For more information, see the following tutorial:
        [**Soil Data Access Tutorial**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/SDA-tutorial.html).


### Data Checks Run by the `fetchNASIS()` Function

When you load pedons using the fetchNASIS() function, the following data checks are performed:

- **Presence of multiple map datums**. Results reported to the user and the data are not modified.

- **Inconsistent horizon boundaries**. Pedons with inconsistent horizon boundaries are not loaded.  In most cases, this occurs when the bottom depth of a horizon is not the same as the upper depth of the next lower horizon.

```{r example_a, echo=FALSE, results='show', warning=FALSE}
top <- c(0,38,56,121,135)
bot <- c(30,56,121,135,'')
hzname <- c('A', 'Bt1', 'Bt2', 'Bk', 'R')
d <- data.frame(hzname, top, bot)
d
```
Note the issue above. The bottom depth of the A horizon and the upper depth of the Bt1 horizon should be the same: either 30 or 38 cm. The correct depth needs to be determined.

- **Missing lower horizon depths.** Offending horizons are fixed by replacing the missing bottom depth with the top depth plus 2 cm. In the case of the profile shown above, a bottom depth of 137 cm would be inserted where the depth is missing.

- **Sites missing pedon records**. Data without corresponding horizons are not loaded.


#### How can you find the site ID's where these errors occur and fix them in NASIS?
If errors in the pedon data are detected when loading data using fetchNASIS(), the following "get" functions can trace them back to the corresponding records in NASIS:

- **get('sites.missing.pedons', envir=soilDB.env)**
    - Returns user site ID's for sites missing pedons.
  
- **get('dup.pedon.ids', envir=soilDB.env)**
    - Returns pedon ID's for sites with duplicate pedon ID's.
  
- **get('bad.pedon.ids', envir=soilDB.env)**
    - Returns user pedon ID's for pedons with inconsistent horizon depths.
    
- **get('bad.horizons', envir=soilDB.env)**
    - Returns a dataframe of horizon-level information for pedons with inconsistent horizon depths.

For more information on the design of soilDB functions, see the following documentation: [**Introduction to soilDB**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/soilDB-Intro.html).


### Options That Can Be Set Within fetchNASIS()

There are two default options that can be set within `fetchNASIS(rmHzErrors = TRUE, nullFragsAreZero = TRUE)`.  

- **rmHzErrors = TRUE/FALSE** 
    - Setting this value to **TRUE** (the default) enables checks for horizon depth consistency. Consider setting this argument to **FALSE** if you aren't concerned about horizon-depth errors or if you know that your selected set contains many combination horizons (e.g., consisting of E/Bt horizons or similar two-part horizons described individually for the same depth range). Note that any pedons flagged as having horizon-depth errors (rmHzErrors = TRUE) are omitted from the data returned by `fetchNASIS()`.
    
- **nullFragsAreZero = TRUE/FALSE**
    - Setting this value to **TRUE** (the default) converts null entries for rock fragment volumes to 0. This is typically the right assumption because rock fragment data are typically populated only when observed. If you know that your data contain a combination of omitted information (e.g. no rock fragment volumes are populated) then consider setting this argument to **FALSE.**
  
For more information on the data checks and adjusting the default options to `fetchNASIS()` function, see the following resource: [**Tips on Getting Data from NASIS into R**](https://r-forge.r-project.org/scm/viewvc.php/%2acheckout%2a/docs/soilDB/fetchNASIS-mini-tutorial.html).

## Structure of Pedon Data in a Soil Profile Collection (SPC)

### The `Gopheridge` Sample Dataset
The `gopheridge` sample dataset is very similar to the type of data returned from `fetchNASIS()`. The following demonstration shows the structure of the Soil Profile Collection (SPC) object that is returned by `fetchNASIS()`. 

Before proceeding, you may find it helpful to review the following: [**SoilProfileCollection Object Introduction**](http://ncss-tech.github.io/AQP/aqp/aqp-intro.html). This tutorial provides an excellent overview of how the SPC object is constructed. Also, the manual pages for `soilDB` and `aqp` are accessible (click **index** at the bottom of the **Help** tab in RStudio) by entering the following into the R console: 

```{r, eval=FALSE}
# not run
library(soilDB)
help(soilDB)

# for links to lots of great examples look here!
library(aqp)
help(aqp)
```


Open RStudio, and set up the environment by loading packages and the Gopheridge sample dataset.


```{r gopheridge_a}
options(width=95, stringsAsFactors=FALSE)
library(soilDB)
library(aqp)

# load example dataset
data(gopheridge)

# what kind of object is this?
class(gopheridge)

# what does the internal structure look like?
str(gopheridge, 2)

# let's take a look at the fields at the site and horizon levels within the SPC
siteNames(gopheridge)
horizonNames(gopheridge)
```

#### Quickly generate sketches from a `SoilProfileCollection` object
The `plot()` function applied to a `SoilProfileCollection` object generates sketches based on horizon depths, designations, and colors. The `fetchNASIS()` function automatically converts moist Munsell colors into R-style colors. Multiple colors per horizon are mixed. See `?plotSPC` for a detailed list of arguments and examples.

```{r, fig.width=10, fig.height=4}
par(mar=c(1,1,1,1))
plot(gopheridge, print.id=FALSE)
title('Pedons from the `gopheridge` sample dataset', line=-0.5)
```


#### Subset example of the data in the site-level portion of the SPC

```{r gopheridge_a1, eval=TRUE, echo=FALSE, results='show', warning=FALSE, collapse=TRUE}
s <- site(gopheridge)
# show table of site data
knitr::kable(s[1:2, 1:10])
knitr::kable(s[1:2, 11:20])
knitr::kable(s[1:2, 21:28])
knitr::kable(s[1:2, 28:36])

# use the following to show the data in the R console
#head(site(gopheridge), 2) # show the first 2 lines of the site data
```

#### Subset example of the data in the horizon-level portion of the SPC

```{r gopheridge_a2, eval=TRUE, echo=FALSE, results='show', warning=FALSE, collapse=TRUE}
h <- horizons(gopheridge)
# show table of site data
knitr::kable(h[1:8, 1:10])
knitr::kable(h[1:8, 11:19])
#knitr::kable(h[1:2, 21:28])
#knitr::kable(h[1:2, 28:36])

# use the following to show the data in the R console
#head(horizons(gopheridge), 5) # show the first 5 rows of the horizon data
```

#### Follow along with your own data

Explore the site- and horizon-level data in your own SPC using the following code. Note: You must have pedons in your local NASIS selected set.

```{r owndata_a, results='hide'}
# load required libraries
library(soilDB)
library(aqp)

# load data from a NASIS selected set
f <- fetchNASIS()

# what kind of object is this?
class(f)

# how many pedons
length(f)

# let's take a look at the fields at the site and horizon levels within the SPC
siteNames(f)
horizonNames(f)

# look at the first 2 rows of site and horizon data
head(site(f), 2)
head(horizons(f), 2)
```

How can you find out how many site and horizon records are in the data you just loaded?

## Viewing Pedon Locations
### Plotting Geographic Data Directly in R

**Quick check:** Does the data plot roughly where you expect it?
 
Plotting the data directly as an R graphic can give you some idea of how the data look spatially and whether their distribution approximates what you expect.  Typos are relatively common when coordinates are manually entered. Viewing the data spatially is a quick way to see if any points plot far outside of the geographic area of interest and therefore clearly have an error.


```{r gopheridge_b}
# plot the locations of the gopheridge pedons within R
# Steps:
# 1) subset to a new data frame
# 2) create a spatial points data frame (SPDF)
# 3) plot the data

# load libraries
library(sp)
library(maps)

# subset standard WGS84 decimal degree coordinates from the gopheridge SPC by specifying column names
gopher.locations <- site(gopheridge)[, c('site_id', 'x_std', 'y_std')]

# initialize coordinates in an SPDF
coordinates(gopher.locations) <- ~ x_std + y_std
# define coordinate system
proj4string(gopher.locations) <- '+proj=longlat +datum=WGS84'

# set plot margins
par(mar=c(0,0,0,0))

# plot county boundaries for all of CA
map('county', 'california')
# add pedon data locations, note symbol styling
points(gopher.locations, cex=0.5, pch=3, col='red')

# plot again but zoom in by setting xlim, ylim extents
map('county', 'California', xlim=c(-122.25, -119.75), ylim=c(37, 38.5))
# add pedon data locations, note symbol styling
points(gopher.locations, cex=1, pch=3, col='red')
box()
```

### Displaying Pedon Data in Google Earth
Google Earth is a powerful viewer for point data.  Geographic data is displayed in Google Earth using the Keyhole Markup Language (KML) format.  Using the [plotKML](https://cran.r-project.org/web/packages/plotKML/plotKML.pdf) package, you can easily create a KML file to inspect and view in Google Earth.  See the related material in this tutorial: [**Export Pedons to Google Earth**](http://ncss-tech.github.io/AQP/soilDB/export-points-from-NASIS-to-Google-Earth.html). 

### Exporting Pedon Data to an ESRI Shapefile
Another way you can view the data is to export a shapefile from R.  For further information, see this tutorial: [**Export Pedons to Shapefile**](http://ncss-tech.github.io/AQP/soilDB/export-points-from-NASIS.html).

#### Follow along with your own data

Use the script below to make an R plot of pedon data loaded from your NASIS selected set.

The following script plots the standard lat/long fields from NASIS. In some cases, these fields might be incomplete due to insufficient data or to not having been calculated from UTM coordinates in NASIS. In these cases, you can omit sites with "NA" values in the coordinates a couple of ways. The `na.omit()` or `complete.cases()` functions remove any rows in a dataframe that have "NA" values.

Run the following script on the data loaded from your local NASIS selected set:
```{r r_plot_pedons, eval=FALSE, echo=TRUE, results='show', warning=FALSE}
# load libraries
library(soilDB)
library(sp)
library(maps)

# get pedons from the selected set
f <- fetchNASIS()

# subset standard WGS84 decimal degree coordinates from the gopheridge SPC by specifying column names
f.locations <- site(f)[, c('site_id', 'x_std', 'y_std')]
nrow(f.locations)

# remove any sites lacking standard lat/long coordinates
# notice that there may now be fewer rows of data
f.locations <- na.omit(f.locations)
nrow(f.locations)

# initialize coordinates in an SPDF
coordinates(f.locations) <- ~ x_std + y_std
# define coordinate system
proj4string(f.locations) <- '+proj=longlat +datum=WGS84'

# set plot margins
par(mar=c(0,0,0,0))

# plot pedon locations
plot(f.locations)

# plot in CONUS: good way to check for typos
map('state')
points(f.locations, cex=0.5, pch=3, col='red')

# plot again this time with county boundaries for your state
# ENTER your state!!!
map('county', 'Montana')
# add plot of pedon locations
points(f.locations, cex=0.5, pch=3, col='red')
```

# Working with SPC Data in R

## Summarizing Data

Now that you've loaded some data, you can look at additional ways to summarize data elements and filter the SPC to specific sites of interest. The `table()` function is very useful for quick summary operations.  This function can be combined with other functions, such as `sort()` and `is.na()` or `!is.na()` (is not NA). Follow along with your own data.

```{r owndata_b, results='hide'}
# summarize which soil taxa we have loaded
table(f$taxonname)
# sort results in descending order
sort(table(f$taxonname), decreasing=TRUE)

# could do the same thing for taxonomic subgroups or any column of the SPC at the site or horizon levels
table(f$tax_subgroup)
sort(table(f$tax_subgroup), decreasing=TRUE)

# table() is also useful when testing for null data using IS NA, is.na() or IS NOT NA, !is.na()
table(is.na(f$tax_subgroup))
table(!is.na(f$tax_subgroup))

# it can also be applied to horizon level columns in the SPC
sort(table(f$texture), decreasing=TRUE)
```

### Filtering Data Using Pattern Matching

A variety of methods are available to subset a collection of soil profiles or an SPC. The results can then be placed into another SPC. This capacity can be useful for generating subset SPC objects from the original dataset.  The following examples use the `grep()` function to pattern match within the data, create an index of the SPC for records that match the specified pattern within that column, and then use that index to filter to specific sites and their corresponding profiles. Patterns are specified in [regular expression](http://regexr.com/) (REGEX) syntax.

This process can be applied to many different columns in the SPC based on how you need to filter the data.  This example pattern matches on the `tax_subgroup` column, but another useful application might be to pattern match on geomorphology or parent material.

Note that the `grep()` below also has an ***invert option***, which is specified as either true or false (the default is false).  When set to true, this option is very useful for excluding the results of the pattern matching process by inverting the selection.

```{r owndata_d, results='hide'}
# say we wanted to look at what the variation of particle size classes are within a specific subgroup?
# use of grep() to filter and create an index, then apply that index to the SPC 
# and create a new SPC called 'f1' using the square bracket notation
idx <- grep('lithic', f$tax_subgroup, invert=FALSE)
# save this subset of 'lithic' soils for later use  
f1 <- f[idx, ]
# or use the index directly to summarize a field
sort(table(f$part_size_class[idx]), decreasing=TRUE)
```

Do a quick graphical check to ensure that the "lithic" profiles are selected. Plot them in R using the `SoilProfileCollection` "plot" method (e.g., specialized version of the generic `plot()` function).

```{r owndata_e, results='show', fig.width=8, fig.height=4}
# adjust margins
par(mar=c(1,0,0,1))
# plot the first 10 profiles of the 'f1' subset
# limit plotting to a depth of about 60cm
plot(f1[1:10, ], label='site_id', max.depth=60)
title('Pedons with the word "lithic" at subgroup-level of Soil Taxonomy', line=-2)
```

For more information on using regular expressions in `grep()` for pattern matching operations, see: [Regular-expression-syntax](https://www.gnu.org/software/findutils/manual/html_node/find_html/grep-regular-expression-syntax.html).

#### Additional syntax options for REGEX pattern matching

  - `|` Equivalent to "or" in SQL.
    - Example:  `grep('loamy | sandy', f$part_size_class)`
  - `^` Anchors to the left side of the string.
    - Example:  `grep('^sandy', f$part_size_class)`.
  - `$` Anchors to the right side of the string.
    - Example:  `grep('skeletal$', f$part_size_class)`.


### Filtering Data by Specifying a Criteria Using the `which()` Function

Another method of subsetting a collection of soil profiles is to specify a criteria using the `which()` function. The following examples use the `which()` and `grep()` functions to reference the indexing of the SPC to create subsets and to filter for specific sites or their corresponding profiles.

```{r owndata_f, results='show', fig.width=8, fig.height=4}
# say we wanted to look at what the variation of particle size classes are within a specific subgroup?
# first: use grep to pattern match the tax_subgroup field for the string 'aqu'
idx <- grep('aqu', f$tax_subgroup)
# save this subset
f1 <- f[idx, ]
# check taxonomic range of particle size classes in the data
sort(table(f1$tax_subgroup), decreasing=TRUE)
sort(table(f1$part_size_class), decreasing=TRUE)

# then further query the subset for only those profiles with particle size class of 'sandy-skeletal'
# notice: a double equal sign '==' is used for exact character or numeric criteria
idx <- which(f1$part_size_class == 'sandy-skeletal')
# save this subset
f2 <- f1[idx, ]
table(f2$part_size_class)
# plot  profiles 1 thru 10
par(mar=c(0,0,2,1))
plot(f2[1:10, ], label='site_id')
title('Sandy-skeletal particle size control section class')
```

#### Additional syntax options for use in `which()` criteria

  - `%in%` Equivalent to IN() in SQL. Can use `c()` to concatenate lists of vectors.
    - Example:   `which(f$part_size_class %in% c('loamy-skeletal', 'sandy-skeletal'))`
  - `!=` Not-equal-to character "string."
  - `==` Note in the example above that R uses a double equal sign as "equal to."
  - `<, >, <=, >=` Less than, greater than, less than or equal to, and greater than or equal to.


### Extracting Site and Horizon Data

Soil Profile Collections are designed to be dismantled so they can work more easily with either site or horizon data. The SPC has a slot for site-level data and a slot for horizon-level data. You can reference these slots using the `site()` and `horizons()` functions within the AQP package. These "get" functions extract all the site or horizon variables as a dataframe for further use.  

```{r owndata_g, results='show'}
# extract site data from SPC into dataframe 's'
s <- site(f)
names(s)
# extract horizon data from SPC into dataframe 'h'
h <- horizons(f)
names(h)
```
You can also use these functions when referencing the data within an SPC to specify that you want to look specifically in the site or horizon data. 

### Review of Data Checks Run by `fetchNASIS()`
Now that you've loaded some data and learned a little about how to filter data in the SPC, you can quickly review some of the `get()` functions used to track data issues detected in the process of loading data back to the NASIS records in your selected set.

```{r owndata_a1, eval=FALSE, results='hide'}
# use each one of these to return a vector of the pedons where errors were detected
#get('sites.missing.pedons', envir=soilDB.env)
#get('dup.pedon.ids', envir=soilDB.env)
#get('bad.pedon.ids', envir=soilDB.env)
# example of pedon_id's returned
#[1] "2011MT0810001" "2011MT0810009" "2011MT00810015" "2011MT0810027" "2011MT0810034"

#get('bad.horizons', envir=soilDB.env)

# How could you then remove these from your SPC?
# since the get() returns the string of bad pedon id's we can use a which() to query any pedon id's that don't match the bad id's
idx <- which(horizons(f)$pedon_id != get('bad.pedon.ids', envir=soilDB.env))
f <- f[idx, ]
```
Another useful function is `dput()`, which concatenates a variable. It converts something like this:

"2011MT0810001" "2011MT0810009" "2011MT00810015" "2011MT0810027" "2011MT0810034"

into a comma delimited string like this:

c("2011MT0810001", "2011MT0810009", "2011MT00810015", "2011MT0810027", "2011MT0810034").

Such a string can be copied and then pasted back as a concatenated string or could even be used as string for NASIS list queries. The `dput()` function is also helpful when sending questions or examples to colleagues via email.


## Functions
If objects are analogous to nouns in a spoken language, then functions are analogous to verbs. A function defines an action that (typically) results in the creation of an object. An object that a function "acts on" is referred to as an "argument" of that function. Follow this terminology with a very basic example:

```{r }
# make a new object with a sequence of values from 1 to 10
a <- seq(from=1, to=10, by=1)
# result
#[1]  1  2  3  4  5  6  7  8  9 10

# define a function that performs a simple action on a vector of numbers
# "i" is a temporary object created inside of the context of this function based on the argument supplied
aFunction <- function(i) {
  # do something
  res <- i * 10
  # send the results back to the calling context
  return(res)
}

# apply our new function to object "a"
aFunction(a)
```


### Defining a Function
Functions bundle operations and can come in the form of small helper functions or involve larger multi-step processes that can be re-used.  This section focuses on functions that work with the horizon data in the SPC.  The general workflow typically goes like this:

- The need for a function is realized,

- steps for a function are defined,

- the function is applied iteratively to each soil profile,

- results are returned, and

- results may, in many cases, need to be further summarized before joining back to the original SPC.


### Function Examples

Functions can bundle a series of operations and then be applied to each profile within a collection (SPC) using `profileApply()`.  Consider, for example, if you wanted to use some pedon data to model  depth to the top of an argillic horizon.  Ideally, this task would be performed using data from the pedon diagnostic features table. However, these records are not always consistently populated. So, how else might you accomplish this task?  One way to try would be using horizon designations to derive a depth to the "t" suffix horizon designation.

What steps would return an upper depth to an argillic horizon for each site?

 - *Extract* the horizon data for each profile,
 - *iterate* through the horizon designations (hzname) and search for the pattern "t",
 - *apply* the function to each profile via `profileApply()`,
 - *summarize* the data returned by the function to one value per profile, and
 - *join* the summarized depth value back to the site data.
 
#### Example using the Gopheridge sample dataset

```{r owndata_i_gopher, echo=TRUE, results='show', warning=FALSE}
# load required libraries
library(aqp)
library(soilDB)
library(plyr)

# load example dataset
data(gopheridge)

# rename gopheridge as SPC object 'f'
f <- gopheridge

# the argument 'i' is a single soil profile
findBtHorizons <- function(i) {
  # extract horizons for current profile
  h <- horizons(i) 
  # search for pattern 't' in horizon designations
  idx <- grep('t', h$hzname)
  # subset these horizons
  h2 <- h[idx, ] 
  # subset columns in resulting dataframe
  res <- h2[, c('peiid', 'phiid', 'hzname', 'hzdept', 'hzdepb', 'clay', 'phfield')]
  # return data
  return(res)
}

# apply function to a single profile as a demonstration
findBtHorizons(f[1, ])
```

You still need to summarize to get the upper depth from multiple "Bt" horizons per profile. Also, note that additional variables were returned by the function.

Next, apply the function to all profiles in your collection. The results are a list of dataframes.
```{r}
l <- profileApply(f, FUN=findBtHorizons, simplify=FALSE)

# convert list into a dataframe, dropping all pedons with no 't' horizons 
Bt.horizons <- ldply(l)
```


You still need to reduce this to one depth value per profile. The `ddply()` function conveniently iterates over groups of rows in a dataframe and computes summaries (similar to `GROUP BY` in SQL). The group-wise summaries are re-combined into a new dataframe along with ID's for each group.
```{r fig.width=4.5, fig.height=3.5}
# standard ddply syntax is as follows (type '?ddply' into the R console):
# ddply(.data, .variables, .fun)
Bt.horizons.top <- ddply(Bt.horizons, 'peiid', summarise, depth_to_argillic_cm=min(hzdept))

# since we have peiid in the 'Bt.horizons.top' dataframe we can easy join it back to site data in the SPC
# NOTE: the when used in conjunction with site(), the assignment operator performs a left-join
site(f) <- Bt.horizons.top

# summary of depth to carbonates in the data using a histogram
hist(f$depth_to_argillic_cm, xlab='Depth to Bt Horizon (cm)', main='')
```
 
What is a potential problem with this operation, and what was not accounted for?

```{r owndata_i1_gopher, eval=FALSE, echo=TRUE, results='show', warning=FALSE}
# This time we'll go after the thickness of the organic horizons where present.

# load library
library(plyr)

f.organic <- function(i) {
  # extract horizons
  h <- horizons(i)
  # pattern match for 'O' horizon designations in horizon data
  idx <- grep('O', h$hzname)
  h2 <- h[idx, ] 
  # subset results
  res <- h2[, c('peiid', 'phiid', 'hzname', 'hzdept', 'hzdepb')]
  # return data
  return(res)
}

# apply function to each profile, results are a list of data.frames
l <- profileApply(f, FUN=f.organic, simplify=FALSE)

# convert list into a dataframe
organic <- ldply(l)

# show contents of the 'organic' dataframe
head(organic)

# summarize this dataframe down to one max bottom depth value for each profile
organic1 <- ddply(organic, 'peiid', summarise, organic_thickness_cm=max(hzdepb))

# since we have peiid in the 'organic1' dataframe we can join back to site data in the SPC
site(f) <- organic1

# summary of organic thickness in the data
hist(f$organic_thickness_cm, xlab='Thickness of Organic horizons (cm)', main='')
```

How would you subtract the organic_thickness_cm values from depth_to_argillic_cm values to get a more realistic upper depth to argillic features?

#### Follow along with your own data

The following example uses pedon data to model the depth to calcium carbonate.  

What steps would be needed to return an upper depth to carbonates for each site?

 - *Extract* the horizon data for each profile,
 - *iterate* through the horizon designations (hzname) pattern matching for "k",
 - *apply* the function to each profile via `profileApply()`,
 - *summarize* the data returned by the function to one value per profile, and
 - *join* the summarized depth value back to the site data.

Note: This example may need modification to evaluate different horizon designations than the ones used here as these may not be present in your currently loaded data.
 
```{r owndata_i, eval=FALSE, echo=TRUE, results='show', warning=FALSE}
# load required libraries
library(plyr)

# the argument 'i' is a single soil profile
f.limy <- function(i) {
  # extract horizons for current profile
  h <- horizons(i) 
  # search for pattern 'k' in horizon designations
  idx <- grep('k', h$hzname)
  # subset these horizons
  h2 <- h[idx, ] 
  # subset columns in resulting dataframe
  res <- h2[, c('peiid', 'phiid', 'hzname', 'hzdept', 'hzdepb', 'phfield', 'effervescence')]
  # return data
  return(res)
}

# apply function to each profile, results are a list of dataframes
l <- profileApply(f, FUN=f.limy, simplify=FALSE)

# convert list into a dataframe, dropping all pedons with no 'k' horizons 
limy <- ldply(l)

# view the top 6 rows
head(limy)

# still need to reduce this down to one depth value for each profile
## ddply() will apply a function (summarise the min(hzdept)) then combine the results into a data frame.
## standard ddply syntax is as follows (type '??ddply' into the R console):
## ddply(.data, .variables, .fun = NULL....)

limy1 <- ddply(limy, 'peiid', summarise, depth_to_carbonates_cm=min(hzdept))

# since we have peiid in the 'limy1' dataframe we can easy join it back to site data in the SPC
# this won't work if there were no horizons with 'k' suffice
site(f) <- limy1

# summary of depth to carbonates in the data using a histogram
hist(f$depth_to_carbonates_cm, xlab='Depth to Calcium Carbonates (cm)', main='')
```

If your data contains organic horizons, use the `f.organic` function outlined above to derive values for `organic_thickness_cm`.

You can then subtract the `organic_thickness_cm` values from `depth_to_carbonates_cm` values to get a more realistic upper depth to calcium carbonates.

Consider examples where you truncate the thickness or are interested in summarizing the data for a depth zone, for example, 25 to 100 cm.  What is the weighted average of clay for the 25 to 100 cm thickness?

Simple example: `slab(f, fm= peiid ~ clay, slab.structure=c(25,100), slab.fun=mean, na.rm=TRUE)`.

Excellent examples using the `slice()` and `slab()` functions in the AQP package can be seen at:
[**Introduction to SoilProfileCollection**](http://ncss-tech.github.io/AQP/aqp/aqp-intro.html).

## Getting Additional Data: Extended Data Functions

Additional data related to both site and horizon information can be fetched using the `get_extended_data_from_NASIS()` function. This data is not automatically brought into R because these data elements are typically related to the site or horizon data in one-to-many relationships. For example, multiple diagnostic features could exist within one pedon. Below is a summary of additional information that can be readily brought into R from your NASIS selected set via the `get_extended_data_from_NASIS()` function.

```{r owndata_j1, eval=TRUE, echo=TRUE, results='show', warning=FALSE, collapse=TRUE}
# fetch extended site and horizon data
e <- get_extended_data_from_NASIS_db()

### site and pedon related extended data
# vegetation data summary
colnames(e$veg) 

# diagnostic features
colnames(e$diagnostic) 

# surface rock fragments
colnames(e$surf_frag_summary) 

# geomorphic description
colnames(e$geomorph)

# taxonomic history data
colnames(e$taxhistory)

# linked photo stored in site textnotes
colnames(e$photo) 

# site parent materials
colnames(e$pm)

### horizon related extended data
# rock fragments 
colnames(e$frag_summary) 

# soil texture modifers
colnames(e$texmodifier) 

# soil structure data
colnames(e$struct) 
```

The "Geomorphic description" and "parent materials" attributes are important soil data. They can be useful handles for exploring other data. The soilDB package flattens the nested table structure of parent material and geomorphic description within NASIS into single strings for each site-level record. The pattern matching concepts demonstrated above select profiles based on parts of these strings. The following code generates a simple graphical summary of the 10 most commonly occurring landforms in `fetchNASIS()` data so you can see their frequency of occurrence. 

```{r owndata_c, results='show'} 
# graphically tabulate the occurrence of landforms
# load required libraries
library(soilDB)
library(Hmisc)  # required for dotchart2()
# load data from a NASIS selected set
f <- fetchNASIS()
# create 'lf' object of landform factors sorted in descending order
lf <- sort(table(f$landform.string), decreasing = TRUE)
# plot top 10
dotchart2(lf[1:10], col='black', xlim = c(0, max(lf)), cex.labels = 0.75)
```

### Deriving Thicknesses of Diagnostic Features

#### Boolean diagnostic feature columns in the site data

If diagnostic features are populated in the pedon diagnostic features table in NASIS, then Boolean (`TRUE` or `FALSE`) fields are created for each diagnostic feature in the data brought into R by soilDB. These fields can be readily used to model the presence or absence of a diagnostic soil feature by extracting the site data.

You could use the following code to pull the upper depth to calcium carbonates using the "calcic horizon" and/or the "secondary carbonates" diagnostic features. However, data consistency is critical. You can only use those fields if they are consistently populated for all pedons that you are working with in your selected set. As you start working with larger pedon data sets, you will quickly find that there can be great inconsistencies in the way the data were populated by different people in different offices on different surveys over different time frames.

The following is an example of how you could use the diagnostic features (if populated!) from the extended data to determine the thickness of a diagnostic feature of interest.

```{r owndata_j3, results='show', warning=FALSE, fig.width=6, fig.height=4}
# rename gopheridge data
f <- gopheridge
# get diagnostic features associated with pedons loaded from selected set
d <- diagnostic_hz(f)
# summary of the diagnostic features in your data!
unique(d$diag_kind)
sort(table(d$diag_kind), decreasing = TRUE)
# subset argillic horizons
d <- d[which(d$diag_kind == 'argillic horizon'), ]
# create a new column and subtract the upper from the lower depth
d$argillic_thickness_cm <- d$featdepb - d$featdept
# create another new column with the upper depth to the diagnostic feature
d$depth_to_argillic_cm <- d$featdept
# omit NA values
d <- na.omit(d)
# subset to pedon records IDs and calculated thickness
d <- d[, c('peiid', 'argillic_thickness_cm', 'depth_to_argillic_cm')]
head(d)
# join these data with existing site data
site(f) <- d
hist(f$argillic_thickness_cm, xlab='Thickness of argillic diagnostic (cm)', main='')
hist(f$depth_to_argillic_cm, xlab='Depth to argillic diagnostic (cm)', main='')
```

#### Follow along with your own data

```{r owndata_j4, eval=TRUE, echo=TRUE, results='show', warning=FALSE}
# start fresh with your own data
f <- fetchNASIS()
# get diagnostic features associated with pedons loaded from selected set
d <- diagnostic_hz(f)
# summary of the diagnostic features in your data!
unique(d$diag_kind)
# top 5 most frequent
sort(table(d$diag_kind), decreasing = TRUE)[1:5]

# subset argillic horizons - or choose your own diagnostic feature and modify this script!
#idx <- which(d$diag_kind == 'your_diagnostic')
#d <- d[idx, ]

# how would you do the rest.....see if you can work it out!

```

What can you do with the Boolean diagnostic feature data?

### Diagnostic Feature Diagrams

```{r owndata_k, eval=TRUE, echo=TRUE, results='show', warning=FALSE}
## work up diagnostic plot based on gopheridge dataset
library(aqp)
library(soilDB)
library(sharpshootR)

# load data
data(gopheridge)

# can limit which diagnostic features to show by setting 'v' manually
v <- c('ochric.epipedon', 'cambic.horizon', 'argillic.horizon', 'paralithic.contact', 'lithic.contact')

# generate diagnostic property diagram
diagnosticPropertyPlot(gopheridge, v, k=5, grid.label='site_id', dend.label = 'taxonname', sort.vars = FALSE)

# plot again, this time with diagnostic features ordered according to co-occurrence
diagnosticPropertyPlot(gopheridge, v, k=5, grid.label='site_id', dend.label = 'taxonname', sort.vars = TRUE)
```

#### Follow along with your own data

Use the following script to generate a diagnostic-feature diagram for the pedon data you've loaded from your NASIS selected set.
Note: If the data includes more than about 20 pedons, the script might generate figures that are very hard to read. You also need to be certain that pedon diagnostic feature were populated in your data.

```{r owndata_l, eval=FALSE, echo=TRUE, results='hide', warning=FALSE}
library(soilDB)
library(sharpshootR)

# load data
f<- fetchNASIS()

# may need to subset to a particular series or taxa here....to reduce the number of pedons!

# select a series of diagnostic properties or automatically pull diagnostic feature columns
# get all diagnostic feature columns from site data by pattern matching on '[.]' in the colnames
idx <- grep('[.]', colnames(site(gopheridge)))
v <- colnames(site(gopheridge))[idx]
# remove 'landform.string' from this vector using a negative index
idx <- which(v == 'landform.string')
v <- v[-idx]
v

# or insert diagnostics of interest found in your data here from the list of possible diagnostics in 'v'
v <- c('ochric.epipedon', 'cambic.horizon', 'argillic.horizon', 'paralithic.contact', 'lithic.contact')

# generate diagnostic property diagram
diagnosticPropertyPlot(f, v, k=5, grid.label='site_id', dend.label = 'taxonname')
```

For more information on generating diagnostic feature diagrams, see the following tutorial:
[**Diagnostic Feature Property Plots**](http://ncss-tech.github.io/AQP/sharpshootR/diagnostic-property-plot.html).


## Common Challenges in Working with Pedon Data

 - Consistency
    - Missing data
 - Confidence in the observations
    - Uncertainty with depth
 - Description style differences
    - Depth described, horizonation usage styles
 - Legacy data vintage
    - Decadal span of data
    - Taxonomy updates, horizon nomenclature
 - Location confidence
    - Origin of the location information
    - Datum used for data collection
    - Accuracy for GPS values at the time of data collection
    
### Meeting the Challenges
  
  - Graphical display of the data and summary outputs ([**slice-wise aggregation**](http://ncss-tech.github.io/AQP/aqp/profile-summary.html))
  - Generalized Horizon Labels (GHL). Derive an aggregate soil profile and summarize soil properties for groups of similar soils. 
      - More on that process can be seen in the following tutorial:
      [**GHL Aggregation Presentation**](http://ncss-tech.github.io/AQP/presentations/ghl-aggregation.html) and [**GHL Aggregation Tutorial**](http://ncss-tech.github.io/AQP/aqp/gen-hz-application.html).

For more information regarding difficult pedon data, see the following tutorial in the "aqp" package:  
[**Dealing with Troublesome data**](http://ncss-tech.github.io/AQP/aqp/dealing-with-bad-data.html).

## 2.4 References

 * [**Tutorials on the AQP website**](http://aqp.r-forge.r-project.org/)
 * [**Package 'aqp' manual**](https://cran.r-project.org/web/packages/aqp/aqp.pdf)
 * [**Package 'soilDB' manual**](https://cran.r-project.org/web/packages/aqp/soilDB.pdf)
 * [**Package 'sharpshootR' manual**](https://cran.r-project.org/web/packages/aqp/sharpshootR.pdf)
 * [**Package 'plyr' manual**](https://cran.r-project.org/web/packages/plyr/plyr.pdf)


### 2.4.1 Additional Resources

 * [**Quick R website**](http://www.statmethods.net/)
 * [**Simple R tutorial**](http://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf)
 
Venables, W.N., D.M. Smith, and the R Core Team. 2015. Introduction to R, Notes on R: A programming environment for data analysis and graphics, version (3.2.3, 2015-12-10). [https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf).

Wickham, H. 2014. Advanced R. CRC Press, New York. [http://adv-r.had.co.nz/](http://adv-r.had.co.nz/).



----------------------------
This document is based on `aqp` version `r utils::packageDescription("aqp", field="Version")`, `soilDB` version `r utils::packageDescription("soilDB", field="Version")`, and `sharpshootR` version `r utils::packageDescription("sharpshootR", field="Version")`.



